### Notes (05/17)
---
1. Using env `earth2mip_graphcast` located here: `/glade/work/jmelms/software/miniconda3/envs/earth2mip_graphcast`. This has the customizations needed to run tendency reversion tests and use graphcast in the Earth2MIP framework, so I think we'll need to use it (or a similar version) for DCMIP. Unfortunately I haven't kept a greaaaat log of the modifications I've made to it, but it's a clone of e2mip and therefore git status reveals all the ways in which it's been changed. 
2. We're planning to use `graphcast_operational` for DCMIP25 because it most closely matches our other models; it's 0.25Â° horizontal, 13-level, 6-hour timestep model in u, v, w, T, z, q, and some single-level fields (doesn't use 6-hourly precipitation, which simplifies the IC a lot). 
3. GPU memory consumption for `graphcast_operational` is ~60GB, which means we definitely still need the H100s for it. We speculated that since it had 1/3 as many levels as `graphcast` it would be about 3x as efficient, but it does not appear to be so. 
4. Garrett said as much from the beginning, but all versions of `graphcast` take two input timesteps to produce one output timestep, and run autoregressively: 
$$
x_{t+1} = M(x_{t-1}, x_{t})
$$
This complicates the experiments a little bit. In the Hakim and Masanam (2024) steady tropical heating experiment, for example, should both $t=-1$ and $t=0$ have the heating perturbation applied, or should it be absent in the first and added only to the second? We'll have to think about how to structure the two ICs based on this. 
5. All versions of graphcast claim to use `top_net_longwave_radiation` as a forcing for the model, but they run just fine if you don't provide the model with any particular values of this forcing. What's going on here? Well, turns out that "not providing a forcing" doesn't actually do anything. If you leave the `forcing` input blank, the model calls the function `tplwr` and uses the date of the run to derive incoming radiation. 
6. I made a few changes to `inference_graphcast.py` as well, so make sure to copy that file before running. 
7. Currently, `graphcast` seems to run fine (see output `era5_ic_graphcast.nc`), but neither the homebrew or standard method of running `graphcast_operational` is producing anything usable, even after making sure all input arrays were correct. Or not? Let's see... turns out the standard code for `graphcast_operational` is apparently not finding the correct values for MSL? Let's look into why this is, because then we can get that running and have something to compare the homebrew against it. Solution: just had to undo the problem I created with my tp06 fixer in the cds.py file. Now the standard `graphcast_operational` run produces reasonable output! Time to work on getting the same from the homebrew. One possible problem: graphcast appears to want latitudes from -90 to 90, but the data comes out of ERA5 (and is used for SFNO) from 90 to -90. Once flipped, output should be correct? If you fix another silent-but-violent bug that I left in the inference utils (w_file generated differently than all other vars!), then yes, it works as expected. 